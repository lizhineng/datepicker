/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var index$2 = function isMergeableObject(value) {
	return isNonNullObject(value) && isNotSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isNotSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue !== '[object RegExp]'
		&& stringValue !== '[object Date]'
}

function emptyTarget(val) {
    return Array.isArray(val) ? [] : {}
}

function cloneIfNecessary(value, optionsArgument) {
    var clone = optionsArgument && optionsArgument.clone === true;
    return (clone && index$2(value)) ? deepmerge(emptyTarget(value), value, optionsArgument) : value
}

function defaultArrayMerge(target, source, optionsArgument) {
    var destination = target.slice();
    source.forEach(function(e, i) {
        if (typeof destination[i] === 'undefined') {
            destination[i] = cloneIfNecessary(e, optionsArgument);
        } else if (index$2(e)) {
            destination[i] = deepmerge(target[i], e, optionsArgument);
        } else if (target.indexOf(e) === -1) {
            destination.push(cloneIfNecessary(e, optionsArgument));
        }
    });
    return destination
}

function mergeObject(target, source, optionsArgument) {
    var destination = {};
    if (index$2(target)) {
        Object.keys(target).forEach(function(key) {
            destination[key] = cloneIfNecessary(target[key], optionsArgument);
        });
    }
    Object.keys(source).forEach(function(key) {
        if (!index$2(source[key]) || !target[key]) {
            destination[key] = cloneIfNecessary(source[key], optionsArgument);
        } else {
            destination[key] = deepmerge(target[key], source[key], optionsArgument);
        }
    });
    return destination
}

function deepmerge(target, source, optionsArgument) {
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var options = optionsArgument || { arrayMerge: defaultArrayMerge };
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

    if (!sourceAndTargetTypesMatch) {
        return cloneIfNecessary(source, optionsArgument)
    } else if (sourceIsArray) {
        var arrayMerge = options.arrayMerge || defaultArrayMerge;
        return arrayMerge(target, source, optionsArgument)
    } else {
        return mergeObject(target, source, optionsArgument)
    }
}

deepmerge.all = function deepmergeAll(array, optionsArgument) {
    if (!Array.isArray(array) || array.length < 2) {
        throw new Error('first argument should be an array with at least two elements')
    }

    // we are sure there are at least 2 values, so it is safe to have no initial value
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, optionsArgument)
    })
};

var index = deepmerge;

module.exports = index;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _datepicker = __webpack_require__(2);

var _datepicker2 = _interopRequireDefault(_datepicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = _datepicker2.default;

/**
 * Expose to the global Window object
 */
window.DatePicker = _datepicker2.default;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _deepmerge = __webpack_require__(0);

var _deepmerge2 = _interopRequireDefault(_deepmerge);

var _wheel = __webpack_require__(3);

var _wheel2 = _interopRequireDefault(_wheel);

var _utils = __webpack_require__(4);

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * DatePicker Component
 */
var DatePicker = function () {
    function DatePicker(options) {
        _classCallCheck(this, DatePicker);

        var _default = {
            minDate: null,
            maxDate: null,
            startDate: null,
            endDate: null,
            type: 'date', // the type of the selector {year, month, date}
            multiple: false,
            locale: {
                clear: 'Clear',
                submit: 'Submit',
                startDate: 'Start Date',
                endDate: 'End Date',
                year: 'Year',
                month: 'Month',
                day: 'Day',
                to: 'To'
            },
            debug: false

            // picker options
        };this.options = (0, _deepmerge2.default)(_default, options);

        // store the DOM of picker elements
        this.el = {};

        // current selected type
        this.type = 'start';

        // store the DOM of wheels
        this.wheels = {};

        // Initialize the picker
        this._init();
    }

    /**
     * Initialize the picker
     *
     * 1) render the mask and picker itself
     * 2) binding the mouse and touch events
     */


    _createClass(DatePicker, [{
        key: '_init',
        value: function _init() {
            this._renderMask();
            this._renderPicker();
            this._bindEvents();

            // generate years' wheel store
            this.wheels.year.setStore(_utils2.default.generateYears(this.options.minDate, this.options.maxDate));

            // default switch to start date selector
            this._switchType('start');
        }

        /**
         * Render mask
         */

    }, {
        key: '_renderMask',
        value: function _renderMask() {
            var mask = document.createElement('div');
            mask.classList.add('datepicker-mask');
            this.el.mask = mask;
            document.body.appendChild(mask);
        }

        /**
         * Render picker
         */

    }, {
        key: '_renderPicker',
        value: function _renderPicker() {
            var _this = this;

            var startDate = _utils2.default.dateFormat(this.options.startDate);
            var endDate = _utils2.default.dateFormat(this.options.endDate);

            var markup = '\n            <div class="datepicker-header">\n                <div id="datepicker-clear" class="datepicker-clear">' + this.options.locale.clear + '</div>\n                <div id="datepicker-submit" class="datepicker-submit">' + this.options.locale.submit + '</div>\n            </div>\n            <div id="datepicker-hero" class="datepicker-hero">\n                <div id="datepicker-hero-start" class="datepicker-hero-item datepicker-hero-start">\n                    ' + (this.options.startDate ? startDate : this.options.locale.startDate) + '\n                </div>\n                <div class="datepicker-hero-item datepicker-hero-to">' + this.options.locale.to + '</div>\n                <div id="datepicker-hero-end" class="datepicker-hero-item datepicker-hero-end">\n                        ' + (this.options.endDate ? endDate : this.options.locale.endDate) + '\n                </div>\n            </div>\n            <div class="datepicker-main">\n                <div id="datepicker-year" class="datepicker-main-item datepicker-year">\n                    <ul id="datepicker-wheel-year" class="datepicker-wheel"></ul>\n                </div>\n                <div id="datepicker-month" class="datepicker-main-item datepicker-month">\n                    <ul id="datepicker-wheel-month" class="datepicker-wheel"></ul>\n                </div>\n                <div id="datepicker-day" class="datepicker-main-item datepicker-day">\n                    <ul id="datepicker-wheel-day" class="datepicker-wheel"></ul>\n                </div>\n            </div>\n        ';

            // create a wrapper to DOM, and append the markup in it
            var container = document.createElement('div');
            container.id = 'datepicker-container';
            container.classList.add('datepicker-container');
            container.innerHTML = markup;
            document.body.appendChild(container);

            this.el.container = container;

            // generate wheels
            Array('year', 'month', 'day').map(function (item) {
                // camel case
                var slug = item[0].toUpperCase() + item.substring(1, item.length);

                var el = document.getElementById('datepicker-wheel-' + item);
                _this.wheels[item] = new _wheel2.default(el);

                // callback method name
                var cb = '_handle' + slug + 'Change';
                _this.wheels[item].onChange = _this[cb].bind(_this);
            });

            // store the elements
            this.el.clear = document.getElementById('datepicker-clear');
            this.el.submit = document.getElementById('datepicker-submit');
            this.el.hero = document.getElementById('datepicker-hero');
            this.el.start = document.getElementById('datepicker-hero-start');
            this.el.end = document.getElementById('datepicker-hero-end');
            this.el.year = document.getElementById('datepicker-year');
            this.el.month = document.getElementById('datepicker-month');
            this.el.day = document.getElementById('datepicker-day');
        }

        /**
         * Binding mouse and touch events
         */

    }, {
        key: '_bindEvents',
        value: function _bindEvents() {
            // heros
            this.el.start.addEventListener('click', this._switchType.bind(this, 'start'));
            this.el.end.addEventListener('click', this._switchType.bind(this, 'end'));

            // buttons
            this.options.onClear && this.el.clear.addEventListener('click', this.options.onClear.bind(this));
            this.options.onSubmit && this.el.submit.addEventListener('click', this._handleSubmit.bind(this));
        }

        /**
         * Submit button onClick handler
         */

    }, {
        key: '_handleSubmit',
        value: function _handleSubmit() {
            if (this.options.onSubmit) {
                var _options = this.options,
                    startDate = _options.startDate,
                    endDate = _options.endDate;

                // hide the picker if submit callback if return true

                this.options.onSubmit.call(this, { startDate: startDate, endDate: endDate }) && this.hide();
            }
        }

        /**
         * Switch type
         *
         * @return void
         */

    }, {
        key: '_switchType',
        value: function _switchType(type) {
            this.options.debug && console.debug('[Type] Switch from ' + this.type + ' to ' + type);

            // remove the active class for the previous type
            this.el[this.type].classList.remove('datepicker-hero-active');

            // then, update active class to current type
            this.type = type;
            this.el[this.type].classList.add('datepicker-hero-active');

            // regenerate year data
            var minDate = new Date(this.options.minDate);
            var maxDate = new Date(this.options.maxDate);
            var startDate = new Date(this.options.startDate);
            var endDate = new Date(this.options.endDate);
            this.wheels.year.setStore(_utils2.default.generateYears(type == 'start' ? minDate : this.options.startDate ? startDate : minDate, type == 'start' ? endDate : maxDate, type == 'start' ? true : false));

            var item = this.options[this.type + 'Date'];
            this.options.debug && console.debug('[Wheel] Set value to ' + item);
            this.wheels.year.setValue(item ? new Date(item).getFullYear() : null);
            this.wheels.month.setValue(item ? new Date(item).getMonth() + 1 : null);
            this.wheels.day.setValue(item ? new Date(item).getDate() : null);
        }

        /**
         * Year onChange handler
         *
         * @param payload object
         * @return void
         */

    }, {
        key: '_handleYearChange',
        value: function _handleYearChange(year) {
            var date = this.options[this.type + 'Date'];

            var minDate = new Date(this.options.minDate);
            var maxDate = new Date(this.options.maxDate);
            var startDate = new Date(this.options.startDate);
            var endDate = new Date(this.options.endDate);
            this.wheels.month.setStore(_utils2.default.generateMonths(year.value, this.type == 'start' ? minDate : Math.max(startDate), this.type == 'start' ? Math.min(maxDate, endDate) : maxDate));

            this._handleMonthChange(date ? { text: date.getMonth() + 1 + '月', value: date.getMonth() + 1 } : { text: '1月', value: 1 });

            // if prevous date is not null
            if (date) {
                if (year.value) {
                    this.options[this.type + 'Date'].setFullYear(year.value);
                } else {
                    this.options[this.type + 'Date'] = null;
                }
            } else {
                // if previous date is null
                if (year.value) {
                    this.options[this.type + 'Date'] = new Date(year.value, 0, 1);
                }
            }

            this._updateHeroTitle();
        }

        /**
         * Month onChange handler
         *
         * @param data object New month data
         * @return void
         */

    }, {
        key: '_handleMonthChange',
        value: function _handleMonthChange(month) {
            var date = this.options[this.type + 'Date'];
            var year = this.wheels.year.getValue();

            var minDate = new Date(this.options.minDate);
            var maxDate = new Date(this.options.maxDate);
            var startDate = new Date(this.options.startDate);
            var endDate = new Date(this.options.endDate);
            this.wheels.day.setStore(_utils2.default.generateDays(year, month, this.type == 'start' ? minDate : startDate, this.type == 'start' ? Math.min(maxDate, endDate) : maxDate));

            if (date && month.value) {
                this.options[this.type + 'Date'].setMonth(month.value - 1);
            }

            this._updateHeroTitle();
        }

        /**
         * Month onChange handler
         *
         * @param data object New month data
         * @return void
         */

    }, {
        key: '_handleDayChange',
        value: function _handleDayChange(day) {
            var date = this.options[this.type + 'Date'];

            if (date && day.value) {
                this.options[this.type + 'Date'].setDate(day.value);
            }

            this._updateHeroTitle();
        }

        /**
         * Update hero title after wheels' change
         */

    }, {
        key: '_updateHeroTitle',
        value: function _updateHeroTitle() {
            var year = this.wheels.year.getValue();
            var month = this.wheels.month.getValue();
            var day = this.wheels.day.getValue();

            var title = this.el[this.type];

            var slug = this.type + 'Date';

            if (!year.value) {
                title.innerText = year.text;
                return;
            }

            title.innerText = year.text + month.text + day.text;
        }

        /**
         * Set start date
         *
         * @param date {string|object} Start date
         * @return object This
         */

    }, {
        key: 'setStartDate',
        value: function setStartDate(date) {
            var start = date ? new Date(date) : null;
            this.options.startDate = start;

            if (this.type == 'start') {
                this.wheels.year.setValue(start ? start.getFullYear() : null);
            }

            this.el.start.innerText = start ? start.getFullYear() + '\u5E74' + (start.getMonth() + 1) + '\u6708' + start.getDate() + '\u65E5' : '无限';

            return this;
        }

        /**
         * Set end date
         *
         * @param date {string|object} End date
         * @return object This
         */

    }, {
        key: 'setEndDate',
        value: function setEndDate(date) {
            var end = date ? new Date(date) : null;
            this.options.endDate = end;

            if (this.type == 'end') {
                this.wheels.year.setValue(end ? end.getFullYear() : null);
                this.wheels.month.setValue(end ? end.getMonth() + 1 : null);
                this.wheels.day.setValue(end ? end.getDate() : null);
            }

            this.el.end.innerText = end.getFullYear() + '\u5E74' + (end.getMonth() + 1) + '\u6708' + end.getDate() + '\u65E5';

            return this;
        }

        /**
         * Show the picker
         */

    }, {
        key: 'show',
        value: function show() {
            var _this2 = this;

            this.el.mask.style.opacity = 0;
            this.el.mask.style.display = 'block';
            setTimeout(function () {
                return _this2.el.mask.style.opacity = 1;
            }, 0);

            this.el.container.style.transform = 'translateY(100%)';
            this.el.container.style.display = 'block';
            setTimeout(function () {
                return _this2.el.container.style.transform = 'translateY(0)';
            }, 0);

            document.body.addEventListener('touchmove', _utils2.default.preventDefault);
        }

        /**
         * Hide the picker
         */

    }, {
        key: 'hide',
        value: function hide() {
            var _this3 = this;

            this.el.mask.style.opacity = 0;
            setTimeout(function () {
                return _this3.el.mask.style.display = 'none';
            }, 150);

            this.el.container.style.transform = 'translateY(100%)';
            setTimeout(function () {
                return _this3.el.container.style.display = 'none';
            }, 300);

            document.body.removeEventListener('touchmove', _utils2.default.preventDefault);
        }

        /**
         * Set type for the date picker
         *
         * @param type string Selector type: {year, month, date}
         * @return object
         */

    }, {
        key: 'setType',
        value: function setType(type) {
            this.options.type = type;

            // update the dom we actually use
            switch (type) {
                case 'year':
                    this.el.year.style.display = 'block';
                    this.el.month.style.display = 'none';
                    this.el.day.style.display = 'none';
                    break;
                case 'month':
                    this.el.year.style.display = 'block';
                    this.el.month.style.display = 'block';
                    this.el.day.style.display = 'none';
                    break;
                case 'date':
                    this.el.year.style.display = 'block';
                    this.el.month.style.display = 'block';
                    this.el.day.style.display = 'block';
                    break;
            }

            return this;
        }

        /**
         * Set multiple option
         *
         * @param flag boolean
         * @return object
         */

    }, {
        key: 'setMultiple',
        value: function setMultiple(flag) {
            this.options.multiple = !!flag;

            // display hero section if it's set to multiple option
            if (this.options.multiple) {
                this.el.hero.style.display = 'block';
            } else {
                this._switchType('start');
                this.el.hero.style.display = 'none';
            }
        }
    }]);

    return DatePicker;
}();

exports.default = DatePicker;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _deepmerge = __webpack_require__(0);

var _deepmerge2 = _interopRequireDefault(_deepmerge);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Wheel Component
 */
var Wheel = function () {
    function Wheel(el) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        _classCallCheck(this, Wheel);

        // wheel wrapper
        this.wrapper = el;

        // options
        var _default = {
            rows: 5, // The maximal display rows
            height: 200 // The height of the wheel
        };

        this.options = (0, _deepmerge2.default)(_default, options);

        // data store
        this.store = [];

        // touch data
        this.move = false;
        // touch data structure
        // startX, startY, deltaY, startTranslateY
        this.touches = {};

        // offset of the translateY
        this.translateY = 0;

        // Initialize the wheel
        this._init();
    }

    /**
     * Initilize the wheel
     */


    _createClass(Wheel, [{
        key: '_init',
        value: function _init() {
            // set up the transition animation
            this.wrapper.style.transition = 'transform 300ms cubic-bezier(0.22, 0.61, 0.36, 1)';

            // binding the mouse and touch events
            this.wrapper.addEventListener('mousedown', this, false);
            this.wrapper.addEventListener('mousemove', this, false);
            this.wrapper.addEventListener('mouseup', this, false);
            this.wrapper.addEventListener('touchstart', this, false);
            this.wrapper.addEventListener('touchmove', this, false);
            this.wrapper.addEventListener('touchend', this, false);
        }

        /**
         * Event handler
         */

    }, {
        key: 'handleEvent',
        value: function handleEvent(e) {
            switch (e.type) {
                case 'mousedown':
                case 'touchstart':
                    this._start(e);
                    break;
                case 'mousemove':
                case 'touchmove':
                    this._move(e);
                    break;
                case 'mouseup':
                case 'touchend':
                    this._end(e);
                    break;
            }
        }

        /**
         * The mouse up / touch start handler
         */

    }, {
        key: '_start',
        value: function _start(e) {
            e.preventDefault();
            e.stopPropagation();

            this.move = true;
            this.touches.startX = e.pageX || e.touches[0].clientX;
            this.touches.startY = e.pageY || e.touches[0].clientY;
            this.touches.startTranslateY = this.translateY;
        }

        /**
         * The mouse move / touch move handler
         */

    }, {
        key: '_move',
        value: function _move(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!this.move) return;

            var currentY = e.pageY || e.touches[0].clientY;
            var deltaY = currentY - this.touches.startY;
            this.touches.deltaY = deltaY;
            this._setTranslate(this.touches.startTranslateY + deltaY);
        }

        /**
         * The mouse up / touch end handler
         */

    }, {
        key: '_end',
        value: function _end(e) {
            e.preventDefault();
            e.stopPropagation();

            this.move = false;

            // prevent just a tap
            if (!this.touches.deltaY) {
                // reset the touches data
                this.touches = {};

                return;
            }

            // overflow
            var maxTranslateY = this._getMaxTranslateY();
            if (this.translateY > 0) {
                this._setTranslate(0);
            } else if (this.translateY < maxTranslateY) {
                // underflow
                this._setTranslate(maxTranslateY);
            } else {
                // fix the offset
                var perHeight = this.options.height / this.options.rows;
                var index = Math.abs(Math.round(this.translateY / perHeight));
                this._setTranslate(-index * perHeight);
            }

            // reset the touches data
            this.touches = {};

            // on change callback
            this.onChange && this.onChange(this.getValue());
        }

        /**
         * Set style of translate Y for the wrapper
         *
         * @param y int Translate Y
         * @return object
         */

    }, {
        key: '_setTranslate',
        value: function _setTranslate(y) {
            this.wrapper.style.transform = 'translateY(' + y + 'px)';
            this.translateY = y;
            return this;
        }

        /**
         * Get max translateY of the wrapper according to data store
         *
         * @return int
         */

    }, {
        key: '_getMaxTranslateY',
        value: function _getMaxTranslateY() {
            return -(this.store.length - 1) * 40;
        }

        /**
         * Set data store to the wheel
         *
         * @param data object
         * @return object
         */

    }, {
        key: 'setStore',
        value: function setStore(data) {
            this.store = data;

            // re-render the wheel data item
            this._render();

            // re-calculate the max translate Y
            if (this.translateY < this._getMaxTranslateY()) {
                this.setValue(this.store[this.store.length - 1].value);
            }

            return this;
        }

        /**
         * Set the value for the wheel
         *
         * @praram v string
         * @reutrn ojbect
         */

    }, {
        key: 'setValue',
        value: function setValue(v) {
            var perHeight = this.options.height / this.options.rows;
            var index = this.store.findIndex(function (item) {
                return item.value == v;
            });

            this._setTranslate(-index * perHeight);

            // on change callback
            this.onChange && this.onChange(this.getValue());

            return this;
        }

        /**
         * Get current selected value
         *
         * @return object
         */

    }, {
        key: 'getValue',
        value: function getValue() {
            var perHeight = this.options.height / this.options.rows;
            var index = Math.abs(Math.round(this.translateY / perHeight));
            return this.store[index];
        }

        /**
         * Render the items in the store
         *
         * @return void
         */

    }, {
        key: '_render',
        value: function _render() {
            var _this = this;

            // clear first, clean the old data
            while (this.wrapper.firstChild) {
                this.wrapper.removeChild(this.wrapper.firstChild);
            }

            // insert placeholder before the list
            Array(2).fill('').map(function (p) {
                var li = document.createElement('li');
                li.classList.add('datepicker-wheel-item');
                _this.wrapper.appendChild(li);
            });

            this.store.map(function (item, index) {
                var li = document.createElement('li');
                li.classList.add('datepicker-wheel-item');
                li.dataset.value = item.value;
                li.innerText = item.text;
                _this.wrapper.appendChild(li);
            });

            // insert placeholder after the list
            Array(2).fill('').map(function (p) {
                var li = document.createElement('li');
                li.classList.add('datepicker-wheel-item');
                _this.wrapper.appendChild(li);
            });
        }
    }]);

    return Wheel;
}();

exports.default = Wheel;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Generate years between start and end
 *
 * @param start mixed Start date
 * @param end mixed End date
 * @return array
 */
function generateYears(start, end) {
    var hasInfinite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var startDate = new Date(start);
    var endDate = new Date(end);

    var years = [];
    while (startDate.getFullYear() <= endDate.getFullYear()) {
        years.push({
            text: startDate.getFullYear() + '年',
            value: startDate.getFullYear()
        });

        startDate.setYear(startDate.getFullYear() + 1);
    }

    // Add infinite options if has infinite option
    hasInfinite && years.push({
        text: '无限',
        value: null
    });

    return years;
}

/**
 * Generate months according to year
 *
 * @param year string Year
 * @param min string Min date
 * @param max string Max date
 * @return array
 */
function generateMonths(year) {
    var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    if (!year) {
        return [{ text: '无限', value: null }];
    }

    // the months which need to be generated
    var start = 1;
    var end = 12;
    var minDate = new Date(min);
    var maxDate = new Date(max);

    if (min) {
        if (year == minDate.getFullYear()) {
            start = minDate.getMonth() + 1;
        }
    }

    if (max) {
        // if generated year is same with the year of max date
        if (maxDate.getFullYear() == year && maxDate.getMonth() < 11) {
            end = maxDate.getMonth() + 1;
        }
    }

    var data = [];
    for (var i = start; i <= end; i++) {
        data.push({
            text: i + '月',
            value: i
        });
    }

    return data;
}

/**
 * Generate months according to year and month
 *
 * @param year object Year
 * @param month object Month
 * @param min string Minimal date
 * @param max string Maximal date
 * @return array
 */
function generateDays(year, month) {
    var min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    if (!year.value || !month.value) {
        return [{ text: '无限', value: null }];
    }

    var start = 1;
    var end = new Date(year.value, month.value, 0).getDate();

    // calculate the minimal days according to min date
    if (min) {
        var minDate = new Date(min);
        if (minDate.getFullYear() == year.value && minDate.getMonth() + 1 == month.value) {
            start = minDate.getDate();
        }
    }

    // calculate the maximal days according to max date
    if (max) {
        var maxDate = new Date(max);
        if (maxDate.getFullYear() == year.value && maxDate.getMonth() + 1 == month.value) {
            end = maxDate.getDate();
        }
    }

    var data = [];
    for (var i = start; i <= end; ++i) {
        data.push({
            text: i + '日',
            value: i
        });
    }

    return data;
}

/**
 * Convert the date object to formatted string
 *
 * @param date mixed Date
 * @param format string Format (TODO)
 * @return string
 */
function dateFormat(date, format) {
    var d = new Date(date);
    return d.getFullYear() + '\u5E74' + (d.getMonth() + 1) + '\u6708' + d.getDate() + '\u65E5';
}

/**
 * Prevent default handler
 *
 * @return void
 */
function preventDefault(e) {
    e.preventDefault();
}

module.exports = {
    generateYears: generateYears,
    generateMonths: generateMonths,
    generateDays: generateDays,
    dateFormat: dateFormat,
    preventDefault: preventDefault
};

/***/ })
/******/ ]);